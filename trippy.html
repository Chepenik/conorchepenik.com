<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Trippy</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/r16/Stats.js"></script>
</head>
<body>
    <canvas id="canvas"></canvas>

    <script>
        console.clear();

        const {sin, cos, PI, floor, round, hypot, atan2, min, max, abs, sign} = Math;
        const Seedrandom = Math.seedrandom;
        const {vec2} = glMatrix;

        requestAnimationFrame(main);

        let canvas, canvasCtx;
        let canvasSize;
        let stats;

        let random, time;
        let mousePos = [0, 0];
        let actors, walls;

        function main(){
            const cont = document.body;
            cont.style.margin = '0';
    
            canvas = document.createElement('canvas');
            cont.appendChild(canvas);
            canvas.style.display = 'block';
    
            canvasCtx = canvas.getContext('2d');
    
            canvasSize = [0, 0];
            resize();
            window.addEventListener('resize', resize);
    
            canvas.addEventListener('mousemove', (e) => {
                mousePos[0] = e.offsetX - canvasSize[0] / 2;
                mousePos[1] = e.offsetY - canvasSize[1] / 2;
            });
    
            initState();
    
            stats = new Stats();
            document.body.appendChild(stats.domElement);
            stats.domElement.style.position = 'absolute';
            stats.domElement.style.right = '0';
            stats.domElement.style.bottom = '0';
    
            const loop = () => {
                stats.begin();
                cycle();
                stats.end();
                requestAnimationFrame(loop);
            };
            requestAnimationFrame(loop);
        }
    
        function resize(){
            canvasSize[0] = innerWidth;
            canvasSize[1] = innerHeight;
            [canvas.width, canvas.height] = canvasSize;
        }
    
        function initState(){
            random = Seedrandom(1)
            time = 0;
    
            genWalls();
            genActors();
        }
    
        function genWalls(){
            walls = [];
            const minSide = min(canvasSize[0], canvasSize[1]);
            for(let i = 0; i < 30; ++i){
                const pos = [
                    canvasSize[0] * (random() - 0.5),
                    canvasSize[1] * (random() - 0.5),
                ];
                const angle = PI * 2 * random();
                const width = minSide / 10 * (0.25 + 0.75 * random());
                const wall = {
                    pos,
                    width,
                    angle,
                    start: [0, 0],
                    end: [0, 0],
                    color: `hsl(${360 * random() |0}, 50%, 50%)`,
                };
                const halfSide = [cos(angle) * width * 0.5, sin(angle) * width * 0.5];
                vec2.sub(wall.start, pos, halfSide);
                vec2.add(wall.end, pos, halfSide);
                walls.push(wall);
            }
        }
    
        function genActors(){
            actors = [];
            const minSide = min(canvasSize[0], canvasSize[1]);
            for(let i = 0; i < 30; ++i){
                const width = minSide / 30 * (0.25 + 0.75 * random());
                const actor = {
                    pos: [
                        canvasSize[0] * (random() - 0.5),
                        canvasSize[1] * (random() - 0.5),
                    ],
                    width,
                    color: `hsl(${360 * random() | 0}, 100%, 50%)`,
                };
                actors.push(actor);
            }
        }
    
        function cycle() {
            const timeDelta = 1 / 60;
            time += timeDelta;
            control({ timeDelta });
            process({ timeDelta });
            render();
        }
    
        function control({ timeDelta }) {
        } // control
    
        function process({ timeDelta }) {
        }
    
        function render() {
            canvasCtx.fillStyle = '#3f3f3f';
            canvasCtx.fillRect(0, 0, ...canvasSize);
    
            canvasCtx.save();
            canvasCtx.translate(canvasSize[0] / 2, canvasSize[1] / 2);
    
            drawActors();
            drawWalls();
            drawWallShadows();
            canvasCtx.globalAlpha = 0.25;
            drawWalls();
            canvasCtx.globalAlpha = 1;
    
            canvasCtx.restore();
        }
    
        function drawWallShadows() {
            const camPos = mousePos;
    
            const minSide = min(canvasSize[0], canvasSize[1]);
            canvasCtx.fillStyle = '#000000';
            const proj = [0, 0];
            for (const wall of walls) {
                canvasCtx.beginPath();
                canvasCtx.moveTo(...wall.start);
                canvasCtx.lineTo(...wall.end);
    
                {
                    vec2.subtract(proj, wall.end, camPos);
                    vec2.normalize(proj, proj);
                    const projDist = minSide * 3;
                    vec2.scaleAndAdd(proj, wall.end, proj, projDist);
                    canvasCtx.lineTo(...proj);
                }
                {
                    vec2.subtract(proj, wall.start, camPos);
                    vec2.normalize(proj, proj);
                    const projDist = minSide * 3;
                    vec2.scaleAndAdd(proj, wall.start, proj, projDist);
                    canvasCtx.lineTo(...proj);
                }
    
                canvasCtx.closePath();
                canvasCtx.fill();
            }
        }
    
        function drawWalls() {
            canvasCtx.lineWidth = 3;
            for (const wall of walls) {
                canvasCtx.beginPath();
                canvasCtx.moveTo(...wall.start);
                canvasCtx.lineTo(...wall.end);
                canvasCtx.strokeStyle = wall.color;
                canvasCtx.stroke();
            }
            canvasCtx.lineWidth = 1;
        }
    
        function drawActors() {
            for (const actor of actors) {
                canvasCtx.beginPath();
                canvasCtx.arc(
                    ...actor.pos,
                    actor.width * 0.5,
                    0, PI * 2,
                );
                canvasCtx.fillStyle = actor.color;
                canvasCtx.fill();
            }
        }
    
        function adjustAngle(a, b, speed) {
            let diff = (PI * 2 + b - a) % (PI * 2);
            if (abs(diff) > PI) diff = -(PI * 2 + ((diff > 0) ? -diff : diff));
            return a + min(abs(diff), speed) * sign(diff);
        }
    </script>
</body>
</html>